generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model Role {
  id          String   @id @default(cuid())
  name        String   @unique
  authLevel   Int      @default(0)
  description String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  users       User[]
}

model User {
  id                String   @id @default(cuid())
  email             String   @unique
  firstName         String
  lastName          String
  yearOfBirth       Int
  gender            Boolean
  hasAccount        Boolean  @default(false)
  password          String?
  clubName          String?
  roleId            String
  isPZAMember       Boolean  @default(false)
  isClubMember      Boolean  @default(false)
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt
  role              Role     @relation(fields: [roleId], references: [id], onUpdate: Cascade, onDelete: Cascade)
  userCompetitions  User_Competition[]
  taskStaffs        TaskStaff[]
  verificationStaff VerificationStaff[]
}

model Category {
  id                String   @id @default(cuid())
  name              String   @unique
  seq               Int      @default(0)
  minAge            Int?
  maxAge            Int?
  userCompetitions  User_Competition[]
  taskCategories    Task_Category[]
}

model Competition {
  id                  String              @id @default(cuid())
  name                String              @unique
  description         String?
  lockResults         Boolean             @default(false)
  lockEnroll          Boolean             @default(false)
  allowFamilyRanking  Boolean             @default(false)
  // Family settings stored as JSON string
  /*
    {
      include: 'all' | 'topN',
      topN?: number,
      includePZAMembers: boolean,
      pzaFilterCategories: string[] | null, // array of Category IDs
      aggregation: 'sum' | 'best' | 'avg',
    }
  */
  familySettings      String?
  // PZA settings stored as JSON string
  /*
    {
      pzaTakesPlaces: boolean,
      pzaFilterCategories: string[] | null, // array of Category IDs
    }
  */
  pzaSettings         String?
  // Self scoring settings stored as JSON string
  /*
    {
      allowSelfScoring: boolean,
      settings: {
        categoryId: string,
        modifyAfterSent: boolean,
        selfScoringFrom?: number,
        selfScoringTo?: number,
      }[]
    }
  */
  selfScoringSettings String?
  isInternal          Boolean             @default(false)
  clubMembersPay      Boolean             @default(false) 
  startDate           DateTime
  endDate             DateTime
  enrollStart         DateTime
  enrollEnd           DateTime
  createdAt           DateTime            @default(now())
  updatedAt           DateTime            @updatedAt
  userCompetitions    User_Competition[]
  tasks               Task[]
  verificationStaff   VerificationStaff[]
}

model User_Competition {
  id                    String      @id @default(cuid())
  startNumber           Int         @default(0)
  userId                String
  competitionId         String
  categoryId            String
  clubName              String?
  isPZAMember           Boolean     @default(false)
  isClubMember          Boolean     @default(false)
  requestsFamilyRanking Boolean     @default(false)
  hasPaid               Boolean     @default(false)
  underageConsent       Boolean     @default(false)
  verified              Boolean     @default(false)
  createdAt             DateTime    @default(now())
  updatedAt             DateTime    @updatedAt
  user                  User        @relation(fields: [userId], references: [id], onUpdate: Cascade, onDelete: Cascade)
  competition           Competition @relation(fields: [competitionId], references: [id], onUpdate: Cascade, onDelete: Cascade)
  category              Category    @relation(fields: [categoryId], references: [id], onUpdate: Cascade, onDelete: Cascade)
  taskUsers             Task_User[]
  userFamilies          User_Family[]

  @@unique([userId, competitionId])
}

model Family {
  id            String   @id @default(cuid())
  name          String
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  userFamilies  User_Family[]
}

model User_Family {
  id          String   @id @default(cuid())
  userCompId  String
  familyId    String
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  userComp    User_Competition @relation(fields: [userCompId], references: [id], onUpdate: Cascade, onDelete: Cascade)
  family      Family           @relation(fields: [familyId], references: [id], onUpdate: Cascade, onDelete: Cascade)

  @@unique([userCompId, familyId])
}

model TaskScoringTemplate {
  id        String   @id @default(cuid())
  name      String   @unique
  settings  String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Task {
  id            String   @id @default(cuid())
  type          String
  name          String
  shortName     String
  // Settings stored as JSON string
  /*
    {
      maxAttempts: number | null,
      timeLimit: number | null,
      scoringSystem: 'normal' | 'zones' | 'linear' | 'ranges' | 'time' | 'multilinear',
      zones?: {
        name: string,
        shortName: string,
        score: number,
      }[],
      ranges?: {
        data: {
          min: number;
          minInclusive: boolean;
          max: number;
          maxInclusive: boolean;
          score: number;
        }[],
        outOfMin: number,
        outOfMax: number,
      },
      linear?: { a: number, b: number },
      multilinear?: {
        data: {
          min: number;
          minInclusive: boolean;
          max: number;
          maxInclusive: boolean;
          a: number;
          b: number;
        }[],
        outOfMin: number,
        outOfMax: number,
      },
      time?: {
        method: 'best' | 'worst' | 'sum' | 'avg',
        transform: 'linear' | 'hyperbolic' | 'ranges',
        ranges?: {
          data: {
            min: number;
            minInclusive: boolean;
            max: number;
            maxInclusive: boolean;
            score: number;
          }[],
          outOfMin: number,
          outOfMax: number
        },
        coeffs?: { a: number, b: number },
      },
    }
  */
  settings       String
  competitionId  String
  createdAt      DateTime          @default(now())
  updatedAt      DateTime          @updatedAt
  competition    Competition       @relation(fields: [competitionId], references: [id], onUpdate: Cascade, onDelete: Cascade)
  categories     Task_Category[]
  userTasks      Task_User[]
  taskStaffs     TaskStaff[]
}

model Task_Category {
  id         String   @id @default(cuid())
  taskId     String
  categoryId String
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  task       Task     @relation(fields: [taskId], references: [id], onUpdate: Cascade, onDelete: Cascade)
  category   Category @relation(fields: [categoryId], references: [id], onUpdate: Cascade, onDelete: Cascade)

  @@unique([taskId, categoryId])
}

model Task_User {
  id          String           @id @default(cuid())
  taskId      String
  userCompId  String
  // Result stored as JSON string
  /*
    {
      attempts: [
        {
          value?: number,
          zone?: { name: string, shortName: string, score: number }
        }
      ],
    }
  */
  data        String
  score       Float             @default(0)
  createdAt   DateTime          @default(now())
  updatedAt   DateTime          @updatedAt
  task        Task              @relation(fields: [taskId], references: [id], onUpdate: Cascade, onDelete: Cascade)
  userComp    User_Competition  @relation(fields: [userCompId], references: [id], onUpdate: Cascade, onDelete: Cascade)

  @@unique([taskId, userCompId])
}

model TaskStaff {
  id        String   @id @default(cuid())
  userId    String
  taskId    String
  fromTime  DateTime
  toTime    DateTime
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user      User     @relation(fields: [userId], references: [id], onUpdate: Cascade, onDelete: Cascade)
  task      Task     @relation(fields: [taskId], references: [id], onUpdate: Cascade, onDelete: Cascade)
}

model VerificationStaff {
  id          String      @id @default(cuid())
  userId      String
  compId      String
  fromTime    DateTime
  toTime      DateTime
  createdAt   DateTime    @default(now())
  updatedAt   DateTime    @updatedAt

  user        User        @relation(fields: [userId], references: [id], onUpdate: Cascade, onDelete: Cascade)
  competition Competition @relation(fields: [compId], references: [id], onUpdate: Cascade, onDelete: Cascade)

  @@unique([userId, compId])
}
